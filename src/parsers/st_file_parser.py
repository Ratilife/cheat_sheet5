"""
    Модуль st_file_parser.py

    Предназначен для парсинга и обработки структурированных текстовых файлов (ST-файлов)
    с использованием ANTLR4. Обеспечивает:
    1. Чтение и анализ структуры ST-файлов
    2. Удаление элементов (шаблонов и папок)
    3. Сохранение изменений обратно в файл

    Основные компоненты:
    - STFileParserWrapper: основной класс для работы с файлами
    - ExceptionErrorListener: обработчик ошибок парсинга
    - StructureListener: слушатель для построения структуры файла
"""

import os
# Импорт компонентов ANTLR
from antlr4 import FileStream, CommonTokenStream, ParseTreeWalker
from antlr4.error.ErrorListener import ErrorListener
from src.ANTLR4.STFileLexer import STFileLexer
from src.ANTLR4.STFileParser import STFileParser
from src.ANTLR4.STFileListener import STFileListener
# ===================================================================
# КЛАССЫ ДЛЯ ПАРСИНГА ST-ФАЙЛОВ
# ===================================================================

class STFileParserWrapper:
    """
        Класс-обёртка для работы с файлами формата ST (структурированные шаблоны).

        Основное назначение:
        --------------------
        STFileParserWrapper предоставляет высокоуровневый API для операций с ST-файлами, таких как парсинг, модификация структуры, удаление шаблонов и папок, а также сохранение изменений в файл. Класс инкапсулирует все низкоуровневые детали работы с AST, лексическим и синтаксическим анализом, обеспечивая удобный и безопасный интерфейс для бизнес-логики приложения.

        Ключевые возможности:
        ---------------------
        - **Парсинг ST-файла:**
          Преобразует ST-файл в иерархическую структуру Python-словаря с сохранением всех папок и шаблонов. Корневой элемент структуры автоматически именуется по имени файла (без расширения).
        - **Удаление шаблонов и папок:**
          Позволяет удалять шаблоны (template) и папки (folder) по имени с автоматическим обновлением структуры данных.
        - **Рекурсивная фильтрация:**
          Внутренние методы класса реализуют гибкую рекурсивную фильтрацию структуры для поддержки вложенных папок и сложной иерархии.
        - **Генерация ST-содержимого:**
          Поддерживает обратное преобразование структуры Python в формат ST согласно грамматике STFile.g4, что позволяет сохранять изменённые файлы в корректном виде.
        - **Обработка ошибок:**
          Гарантирует возврат базовой структуры даже в случае ошибок парсинга, что обеспечивает стабильность работы приложения.
        - **Лёгкая интеграция:**
          Класс легко расширять и интегрировать в другие части системы благодаря четко определённым методам и единому формату представления структуры.

        Методы:
        -------
        - `parse_st_file(file_path)`: Парсит ST-файл и возвращает его структуру и имя корня.
        - `remove_template(file_path, template_name)`: Удаляет шаблон по имени и сохраняет изменения.
        - `remove_folder(file_path, folder_name)`: Удаляет папку по имени и сохраняет изменения.
        - `_remove_from_structure(structure, filter_fn)`: Рекурсивно фильтрует структуру по пользовательскому критерию.
        - `_save_structure(file_path, structure)`: Сохраняет отредактированную структуру обратно в файл.
        - `_generate_st_content(structure)`: Генерирует строку содержимого ST-файла из структуры Python.

        Использование:
        --------------
        Класс предназначен для использования в качестве базового компонента для всех операций с ST-файлами в системе, где требуется структурный доступ к данным, их модификация и сохранение, а также интеграция с пользовательским интерфейсом или другими модулями обработки данных.

        Исключения:
        -----------
        Методы класса выбрасывают информативные исключения (ValueError, IOError) в случае ошибок чтения, записи или некорректного формата файла, что облегчает отладку и обработку ошибок на уровне приложения.

        Пример:
        -------
            parser = STFileParserWrapper()
            structure = parser.parse_st_file('example.st')
            parser.remove_template('example.st', 'SomeTemplate')
            parser.remove_folder('example.st', 'SomeFolder')
        """
    def parse_st_file(self, file_path) -> dict:
        """
           Парсит ST-файл и возвращает его иерархическую структуру.

           Данный метод выполняет разбор (парсинг) файла в формате ST (Structured Text) и строит его иерархическую структуру.
           Для этого используется парсер, сгенерированный на основе ANTLR, и специальный слушатель, собирающий структуру данных
           во время обхода дерева разбора.

           Параметры:
               file_path (str): Путь к ST-файлу, который требуется распарсить. Предполагается, что файл закодирован в UTF-8.

           Возвращает:
               dict: Словарь с двумя ключами:
                   - 'structure': иерархическая структура файла (обычно список или вложенные словари/списки),
                   полученная с помощью слушателя StructureListener.
                   - 'root_name': имя корневого элемента, совпадает с именем файла без расширения.

           Особенности:
               - В случае возникновения любой ошибки (например, если файл не найден, некорректен синтаксис или отсутствуют зависимости),
               метод возвращает "пустую" структуру (пустой список) и имя файла без расширения.
               - Для разбора используются классы FileStream, STFileLexer, STFileParser, StructureListener и ParseTreeWalker,
               а также настраивается пользовательский обработчик ошибок ExceptionErrorListener.
               - Имя корня структуры автоматически устанавливается в имя файла без расширения.

           Исключения:
               Все исключения перехватываются и не пробрасываются наружу — в случае ошибки возвращается структура по умолчанию.

           Пример использования:
               result = parser.parse_st_file("example.st")
               print(result['structure'])
               print(result['root_name'])
           """
        try:
            # Создание входного потока с указанием кодировки
            input_stream = FileStream(file_path, encoding="utf-8")
            # Лексический анализ
            lexer = STFileLexer(input_stream)
            tokens = CommonTokenStream(lexer)
            # Синтаксический анализ
            parser = STFileParser(tokens)

            # Устанавливаем обработчик ошибок
            parser.removeErrorListeners()
            parser.addErrorListener(ExceptionErrorListener())
            # Парсинг структуры файла
            tree = parser.fileStructure()
            # Создание и настройка слушателя
            listener = StructureListener()
            file_name = os.path.splitext(os.path.basename(file_path))[0]
            listener.root_name = file_name  # ИЗМЕНЕНИЕ: Имя файла в listener
            # Обход дерева разбора
            ParseTreeWalker().walk(listener, tree)

            return {
                'structure': listener.get_structure(),
                'root_name': listener.root_name
            }
        except Exception as e:
            # Возвращаем базовую структуру при ошибке парсинга
            return {
                'structure': [],
                'root_name': os.path.splitext(os.path.basename(file_path))[0]
            }

    # Добавляем методы в STFileParserWrapper:
    def remove_template(self, file_path, template_name) -> None:
        """
            Удаляет указанный шаблон (template) из ST-файла.

            Данный метод выполняет удаление шаблона с заданным именем из структуры файла Structured Text (ST).
            Процесс включает парсинг исходного файла, фильтрацию структуры для исключения нужного шаблона,
            а затем сохранение обновленной структуры обратно в файл.

            Параметры:
                file_path (str): Путь к ST-файлу, в котором необходимо удалить шаблон.
                template_name (str): Имя шаблона, который требуется удалить из файла.

            Возвращает:
                None

            Исключения:
                ValueError: Если файл не удалось распарсить или прочитать (например, файл не найден, невалидный синтаксис и т.п.).
                IOError: При возникновении ошибок в процессе сохранения изменений в файл (например, проблемы с правами доступа, файловой системой и т.д.).

            Алгоритм работы:
                1. Парсит файл и получает его иерархическую структуру с помощью метода self.parse_st_file(file_path).
                2. Если структура не получена, выбрасывает ValueError.
                3. Фильтрует структуру, удаляя из нее элементы типа 'template' с именем, совпадающим с template_name — для этого используется вспомогательный метод _remove_from_structure.
                4. Сохраняет обновленную структуру в файл с помощью метода _save_structure.

            Особенности:
                - Метод не возвращает значение.
                - Использует внутренние методы класса: parse_st_file, _remove_from_structure и _save_structure.
                - Работает только с корректно распарсенными файлами и корректными структурами шаблонов.
                - В случае ошибки чтения или сохранения выбрасывает соответствующее исключение.

            Пример использования:
                parser.remove_template("my_program.st", "MyTemplate")
            """
        structure = self.parse_st_file(file_path)
        if not structure:
            raise ValueError(f"Не удалось прочитать файл {file_path}")
        # Фильтрация структуры (удаление шаблона)
        new_structure = self._remove_from_structure(
            structure,
            lambda x: not (x['type'] == 'template' and x['name'] == template_name)
        )
        # Сохранение изменений
        self._save_structure(file_path, new_structure)

    def remove_folder(self, file_path, folder_name) -> None:
        """
        Удаляет указанную папку (folder) из ST-файла.

        Данный метод осуществляет удаление папки с заданным именем из структуры ST-файла (Structured Text).
        Операция включает парсинг файла, фильтрацию структуры с целью исключения выбранной папки (и всего её содержимого),
        а затем сохранение обновлённой структуры обратно в файл.

        Параметры:
            file_path (str): Путь к ST-файлу, из которого требуется удалить папку.
            folder_name (str): Имя папки, которую необходимо удалить.

        Возвращает:
            None

        Исключения:
            ValueError: Если файл не удалось распарсить или прочитать (например, файл не существует или повреждён).
            IOError: Если возникла ошибка при сохранении изменений в файл (например, нет доступа к записи).

        Алгоритм работы:
            1. Парсит ST-файл с помощью метода self.parse_st_file(file_path) для получения его структуры.
            2. Если структура не получена, выбрасывает исключение ValueError.
            3. Фильтрует структуру, удаляя из неё элементы типа 'folder' с именем, совпадающим с folder_name,
                используя вспомогательный метод _remove_from_structure.
            4. Сохраняет обновлённую структуру обратно в исходный файл с помощью _save_structure.

        Особенности:
            - Метод не возвращает значение.
            - Для фильтрации структуры используется лямбда-функция, исключающая нужную папку по имени и типу.
            - Использует внутренние методы класса: parse_st_file, _remove_from_structure, _save_structure.
            - В случае возникновения исключений чтения или записи, они явно пробрасываются вызывающему коду.

        Пример использования:
            parser.remove_folder("program.st", "ConfigFolder")
        """
        structure = self.parse_st_file(file_path)
        if not structure:
            raise ValueError(f"Не удалось прочитать файл {file_path}")
        # Фильтрация структуры (удаление папки)
        new_structure = self._remove_from_structure(
            structure,
            lambda x: not (x['type'] == 'folder' and x['name'] == folder_name)
        )
        # Сохранение изменений
        self._save_structure(file_path, new_structure)

    def _remove_from_structure(self, structure, filter_fn):

        """
           Рекурсивно фильтрует и модифицирует структуру ST-файла согласно заданной функции-фильтру.

           Данный внутренний метод предназначен для удаления элементов из иерархической структуры ST-файла
           по заданному критерию. Метод применяется для удаления, например, папок или шаблонов, проходя по всей
           структуре, включая все вложенные папки, и исключая те элементы, для которых filter_fn возвращает False.

           Параметры:
               structure (dict): Текущая структура, которую требуется отфильтровать. Ожидается, что она содержит ключ 'structure'
                                 (список элементов верхнего уровня), а у папок дополнительно может быть ключ 'children'.
               filter_fn (callable): Функция-фильтр, принимающая элемент структуры и возвращающая True, если элемент
                                     должен быть сохранён, и False — если он должен быть удалён.

           Возвращает:
               dict: Отфильтрованная структура, в которой удалены все элементы, не прошедшие фильтр, включая вложенные.

           Алгоритм работы:
               1. Фильтрует список элементов верхнего уровня структуры с помощью filter_fn.
               2. Для каждого элемента типа 'folder' рекурсивно вызывает себя для фильтрации вложенных элементов (children).
               3. Возвращает модифицированную структуру.

           Особенности:
               - Метод изменяет структуру "на месте" (in-place), то есть возвращаемый словарь — это та же структура,
                 что и была передана в параметре, но уже отфильтрованная.
               - Метод применяется рекурсивно для всех вложенных папок, что позволяет удалять элементы на любом уровне вложенности.
               - Используется как внутренний вспомогательный метод для удаления шаблонов, папок и других элементов по условию.
               - filter_fn должен быть устойчивым к структуре элементов (например, ожидать наличие ключей 'type', 'name', и т.д.).

           Пример использования:
               filtered = self._remove_from_structure(structure, lambda x: x['type'] != 'template')

           Исключения:
               Метод не обрабатывает исключения — предполагается, что структура имеет корректный формат и filter_fn работает без ошибок.
           """
        # Фильтрация элементов верхнего уровня
        structure['structure'] = [
            item for item in structure['structure']
            if filter_fn(item)
        ]
        # Рекурсивная обработка вложенных папок
        for item in structure['structure']:
            if item['type'] == 'folder':
                item['children'] = self._remove_from_structure(item, filter_fn)
        return structure

    #TODO - рассмотреть перенести метод _save_structure в класс FileManager
    def _save_structure(self, file_path, structure):
        """
            Внутренний метод для сохранения структуры ST-файла на диск.

            Этот метод преобразует переданную структуру (обычно полученную после парсинга и/или модификации ST-файла)
            в строковое представление в формате Structured Text с помощью метода _generate_st_content и сохраняет
            результат в указанный файл. Если при записи возникает ошибка (например, проблемы с доступом или файловой системой),
            возбуждается исключение IOError с описанием.

            Параметры:
                file_path (str): Путь к файлу, в который нужно сохранить структуру.
                structure (dict): Структура данных, которую необходимо сохранить.
                                  Обычно — результат работы методов парсинга или модификации структуры файла.

            Возвращает:
                None

            Исключения:
                IOError: Возникает, если при попытке записи в файл произошла ошибка (например, нет прав на запись,
                         отсутствует директория, диск переполнен и т.п.).

            Алгоритм работы:
                1. Генерирует текстовое содержимое ST-файла на основе структуры с помощью _generate_st_content(structure).
                2. Открывает файл по указанному пути для записи в кодировке UTF-8.
                3. Записывает сгенерированное содержимое в файл.
                4. В случае возникновения любой ошибки при открытии или записи файла возбуждает исключение IOError.

            Особенности:
                - Метод предназначен для внутреннего использования.
                - Генерация содержимого ST-файла делегирована отдельному методу _generate_st_content.
                - Любая ошибка записи оборачивается в исключение IOError с подробным сообщением.

            Пример использования:
                self._save_structure("program.st", structure)
            """
        content = self._generate_st_content(structure)
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
        except Exception as e:
            raise IOError(f"Ошибка сохранения файла: {str(e)}")


    def _generate_st_content(self, structure):
        """
        Генерирует строковое содержимое ST-файла на основе переданной структуры согласно грамматике STFile.g4.

        Данный внутренний метод преобразует иерархическую структуру (словарь с папками и шаблонами), полученную
        после парсинга или модификации ST-файла, в текстовое представление, соответствующее формату Structured Text,
        описанному в грамматике STFile.g4. Используется для сериализации структуры перед сохранением в файл.

        Параметры:
            structure (dict): Структура, которую требуется преобразовать в строку. Ожидается, что структура содержит
                              ключ 'content' с корневой папкой, а далее — вложенные папки и шаблоны.

        Возвращает:
            str: Сгенерированное строковое содержимое файла в формате Structured Text, готовое для записи на диск.

        Алгоритм работы:
            1. Внутренняя рекурсивная функция build_folder(folder) обходит дерево структуры:
                - Если элемент типа 'folder', формирует строку папки и рекурсивно вызывает себя для её потомков.
                - Если элемент типа 'template', формирует строку шаблона с его содержимым.
                - Все элементы объединяются в строку, соответствующую синтаксису STFile.g4.
            2. Метод начинает генерацию с корневой папки, получая её из structure['content'].
            3. Возвращает итоговую строку, которую можно записать в файл.

        Особенности:
            - Формат строки строго соответствует специфике STFile.g4 с фигурными скобками, параметрами и вложенными структурами.
            - Вложенность папок и шаблонов поддерживается рекурсивно.
            - Все значения имен и содержимого корректно подставляются в итоговую строку.
            - Метод предназначен для внутреннего использования, обычно вызывается перед сохранением структуры в файл.

        Пример использования:
            content = self._generate_st_content(structure)
            with open("file.st", "w", encoding="utf-8") as f:
                f.write(content)

        Исключения:
            Метод не обрабатывает ошибки и предполагает, что структура соответствует ожидаемому формату.
        """
        def build_folder(folder):
            children = []
            for child in folder.get('children', []):
                if child['type'] == 'folder':
                    children.append(
                        f'{{1, {{"{child["name"]}", 1, 0, "", ""}}, [\n'
                        f'{build_folder(child)}\n'
                        ']}'
                    )
                elif child['type'] == 'template':
                    children.append(
                        f'{{0, {{"{child["name"]}", 0, 1, "", "{child["content"]}"}}}}'
                    )
            return ',\n'.join(children)

        root_folder = structure['content']
        return (
            f'{{1, {{"{root_folder["name"]}", 1, 0, "", ""}}, [\n'
            f'{build_folder(root_folder)}\n'
            ']}'
        )

    def parse_st_metadata(self, file_path: str, first_lines: list) -> dict:
        """Парсит метаданные ST-файла (шаблоны/папки)"""
        #  TODO 🚧 В разработке: 22.08.2025 - метод parse_st_metadata не устраивает
        return {
            "name": os.path.basename(file_path),
            "type": "file",
            "size": os.path.getsize(file_path),
            "last_modified": os.path.getmtime(file_path),
            # Доп. поля для ST-файлов
            "has_templates": "template" in first_lines[0]
        }

    # парсинг st файлов для metadata_cache

    def parse_st_metadata_level2(self, file_path) -> dict:
        """
        Парсит ST-файл и возвращает его метаданные, пропуская содержимое template блоков
        и ограничиваясь вторым уровнем вложенности.
        """

        try:
            input_stream = FileStream(file_path, encoding="utf-8")
            lexer = STFileLexer(input_stream)
            tokens = CommonTokenStream(lexer)
            parser = STFileParser(tokens)

            parser.removeErrorListeners()
            parser.addErrorListener(ExceptionErrorListener())
            tree = parser.fileStructure()

            # Используем специальный слушатель для метаданных
            listener = MetadataStructureListener()
            file_name = os.path.splitext(os.path.basename(file_path))[0]
            listener.root_name = file_name

            ParseTreeWalker().walk(listener, tree)

            # Получаем полную структуру и ограничиваем глубину
            full_structure = listener.get_structure()
            limited_structure = self._limit_depth_level2(full_structure)

            return {
                'structure': limited_structure,
                'root_name': listener.root_name
            }
        except Exception as e:
            print(f"Ошибка при парсинге: {e}")
            return {
                'structure': [],
                'root_name': os.path.splitext(os.path.basename(file_path))[0]
            }


    def _limit_depth_level2(self, structure, current_level=1):
        """
        Рекурсивно ограничивает структуру вторым уровнем вложенности.
        """
        if current_level > 2:
            return []

        limited_structure = []
        for item in structure:
            if item['type'] == 'folder':
                # Для папок ограничиваем глубину детей
                limited_item = item.copy()
                limited_item['children'] = self._limit_depth_level2(item['children'], current_level + 1)
                limited_structure.append(limited_item)
            else:
                # Для шаблонов оставляем как есть
                limited_structure.append(item)
        return limited_structure

class ExceptionErrorListener(ErrorListener):
    """
        Кастомный обработчик ошибок парсинга для ANTLR.
        Преобразует ошибки синтаксиса в исключения Python с подробным описанием.
    """
    def syntaxError(self, recognizer, offendingSymbol, line, column, msg, e):
        """
                Вызывается при обнаружении синтаксической ошибки.

                Параметры:
                - recognizer: распознаватель, обнаруживший ошибку
                - offendingSymbol: ошибочный символ
                - line: номер строки с ошибкой
                - column: позиция в строке
                - msg: сообщение об ошибке
                - e: исключение (если есть)
        """
        raise Exception(f"Ошибка парсинга в строке {line}:{column} - {msg}")

class StructureListener(STFileListener):

    """
       StructureListener — это слушатель парсера ANTLR, предназначенный для построения иерархической структуры ST-файла
       в виде дерева Python-объектов.

       Основное назначение:
           - Построение дерева структуры файла при разборе синтаксиса ST (например, папки и шаблоны).
           - Поддержка вложенности элементов (папки могут содержать другие папки и шаблоны).
           - Удобное представление структуры файла для последующей обработки.

       Как работает:
           - При инициализации создаётся стек, где каждый элемент — это текущий родитель (например, папка).
           - При входе в папку или шаблон (метод enterEntry) создаётся соответствующий объект (словарь) и добавляется
                в дерево, а для папок — ещё и в стек (чтобы отслеживать вложенность).
           - Для папок поддерживается переход внутрь (добавление в стек), а при выходе (exitEntry) — возврат к родителю
                (извлечение из стека).
           - Для шаблонов добавляется их имя и содержимое, если оно есть.
           - Метод get_structure возвращает итоговую структуру в виде дерева вложенных словарей.

       Атрибуты:
           stack: list — стек для отслеживания иерархии вложенных элементов (папок).
           current_parent: dict — текущий родительский элемент, в который добавляются новые папки или шаблоны.
           root_name: str — имя корневого элемента (по умолчанию "Unnamed").
           found_root: bool — флаг, указывающий, найден ли корневой элемент.

       Методы:
           __init__(): инициализация стека и корневого элемента.
           get_structure(): возвращает дерево структуры файла.
           enterEntry(ctx): обработка входа в элемент структуры (папку или шаблон).
           exitEntry(ctx): обработка выхода из элемента структуры (для папок — возврат к родителю).
       """
    def __init__(self):
        """Инициализация слушателя с пустой структурой."""
        self.stack = [{'children': []}]             # Стек для хранения иерархии элементов
        self.current_parent = self.stack[0]         # Текущий родительский элемент
        self.root_name = "Unnamed"                  # Имя корневого элемента (по умолчанию)
        self.found_root = False                     # Флаг обнаружения корневого элемента


    def get_structure(self):
        """
        Возвращает итоговую иерархическую структуру ST-файла, построенную в процессе парсинга.

        Метод предназначен для получения всей структуры файла в виде дерева,
        где каждый элемент представлен словарём с ключами 'name', 'type', 'children' (для папок)
        или 'name', 'type', 'content' (для шаблонов). Корневым элементом структуры является список,
        содержащий все верхнеуровневые папки и шаблоны.

        Returns:
            list: Список дочерних элементов (папок и шаблонов) на верхнем уровне структуры файла.
        """
        return self.stack[0]['children']


    def enterEntry(self, ctx):
        """
        Обрабатывает вход в элемент структуры ST-файла при разборе дерева синтаксиса.

        В зависимости от типа элемента (папка или шаблон), добавляет соответствующий объект в текущего родителя:
          - Если обнаружен заголовок папки (folderHeader), создаёт новый объект папки с именем,
            добавляет его в список детей текущего родителя, а также помещает в стек для отслеживания вложенности.
            После этого текущий родитель обновляется на новую папку.
          - Если обнаружен заголовок шаблона (templateHeader), извлекает имя шаблона и его содержимое (если оно есть),
            затем добавляет этот шаблон в список детей текущего родителя без изменения вложенности.

        Аргументы:
            ctx: Контекстный объект ANTLR для текущей записи (entry), предоставляющий доступ к заголовкам папок и шаблонов.

        Пример структуры, добавляемой в дерево:
            Для папки:
                {
                    'name': <имя папки>,
                    'type': 'folder',
                    'children': []
                }
            Для шаблона:
                {
                    'name': <имя шаблона>,
                    'type': 'template',
                    'content': <содержимое шаблона>
                }
        """
        if ctx.folderHeader():
            # Обработка папки
            header = ctx.folderHeader()
            name = header.STRING(0).getText()[1:-1]   # Извлечение имени (удаляем кавычки)

            # Создание элемента папки
            new_item = {
                'name': name,
                'type': 'folder',
                'children': []
            }
            # Добавление в текущего родителя и обновление стека
            self.current_parent['children'].append(new_item)
            self.stack.append(new_item)
            self.current_parent = new_item



        elif ctx.templateHeader():
            # Обработка шаблона
            header = ctx.templateHeader()
            name = header.STRING(0).getText()[1:-1]    # Имя шаблона
            # Содержимое шаблона (если есть)
            content = header.STRING(2).getText()[1:-1] if len(header.STRING()) > 1 else ""

            # Добавление шаблона в текущего родителя
            self.current_parent['children'].append({
                'name': name,
                'type': 'template',
                'content': content
            })

    def exitEntry(self, ctx):
        """
        Обрабатывает выход из элемента структуры ST-файла при обходе дерева разбора.

        Этот метод вызывается парсером ANTLR при завершении обработки элемента структуры. Если выход осуществляется из папки,
        происходит возврат к предыдущему родительскому элементу в иерархии:
            - Если текущий элемент — папка (определяется через ctx.folderHeader()), и в стеке есть больше одного элемента,
              то последний элемент удаляется из стека, а текущий родитель обновляется на предыдущий элемент в стеке.
            - Это необходимо для корректного формирования вложенной структуры и правильного распределения дочерних элементов.

        Аргументы:
            ctx: Контекстный объект ANTLR для текущей записи (entry), предоставляющий информацию о типе элемента.

        Пример:
            При выходе из вложенной папки метод корректно возвращает контекст на уровень выше, чтобы продолжить наполнение дерева структуры.
        """
        if ctx.folderHeader() and len(self.stack) > 1:
            # Для папки: возвращаемся к предыдущему родителю
            self.stack.pop()
            self.current_parent = self.stack[-1]

class MetadataStructureListener(StructureListener):
    def __init__(self):
        super().__init__()

    def enterEntry(self, ctx):
        """
            Обрабатывает вход в элемент структуры ST-файла, собирая метаданные без содержимого шаблонов.

            Метод вызывается при входе в элемент структуры (папку или шаблон) во время обхода дерева разбора.
            Для папок создает полную структуру с пустыми дочерними элементами, для шаблонов создает записи
            только с метаданными (без содержимого).

            Args:
                ctx (STFileParser.EntryContext): Контекст элемента структуры, содержащий информацию
                    о папке или шаблоне, полученную от парсера.

            Behavior:
                - Для папок (folderHeader): создает элемент с именем, типом 'folder' и пустым списком детей,
                обновляет стек и текущего родителя для поддержания иерархии.
                - Для шаблонов (templateHeader): создает элемент с именем, типом 'template' и пустым содержимым,
                добавляет к текущему родителю без изменения стека.

            Notes:
                - Извлекает имена элементов из строковых литералов, удаляя окружающие кавычки.
                - Содержимое шаблонов игнорируется (устанавливается в пустую строку).
                - Поддерживает иерархическую структуру через механизм стека.

            Example:
                Для входного элемента:
                    folder "MyFolder" { ... }
                Создает:
                    {'name': 'MyFolder', 'type': 'folder', 'children': []}

                Для входного элемента:
                    template "MyTemplate" "content ignored"
                Создает:
                 {'name': 'MyTemplate', 'type': 'template', 'content': ''}
            """
        # Пропускаем обработку template содержимого
        if ctx.folderHeader():
            # Обработка папки (как обычно)
            header = ctx.folderHeader()
            name = header.STRING(0).getText()[1:-1]

            new_item = {
                'name': name,
                'type': 'folder',
                'children': []
            }
            self.current_parent['children'].append(new_item)
            self.stack.append(new_item)
            self.current_parent = new_item

        elif ctx.templateHeader():
            # Обработка шаблона, но без содержимого
            header = ctx.templateHeader()
            name = header.STRING(0).getText()[1:-1]

            # Добавляем template без содержимого
            self.current_parent['children'].append({
                'name': name,
                'type': 'template',
                'content': ""  # Пустое содержимое
            })